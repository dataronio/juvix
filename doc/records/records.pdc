---
# pandoc -s -r markdown --mathjax records.pdc -o records.html
title: Records (partially) in core
...

# Syntax changes

tl;dr: Add a new kind of datatype for records, a new term for constructing them,
and a new elim for looking up. A usage context is a tree now since we're
tracking fields of records separately.

```haskell
-- in Juvix.Core.Base.Types.Base

data Term primTy primVal
  = ...
  | RecordTy [(Symbol, Usage.T, Term primTy primVal)]
  | Record   (Map Symbol (Term primTy primVal))

data Elim primTy primVal
  = ...
  | Lookup Name Symbol

data Value primTy primVal
  = ...
  | VRecordTy (Map Symbol (Usage.T, Value primTy primVal))
  | VRecord   (Map Symbol (Value primTy primVal))

data Neutral primTy primVal
  = ...
  | NLookups Name [Symbol]

-- in Juvix.Core.IR.Typechecker.Types

data Annotation ext primTy primVal = Annotation
  { annUsage :: UsageTree, -- was Usage.T
    annType :: Core.Value ext primTy primVal
  }

data Tree a
  = TOne a
  | -- | second arg is for any field not mentioned in the map
    TRecord (Map Symbol (Tree a)) (Tree a)

type UsageTree = Tree Usage.T
```


# Type rules

$$
\let\Con\mathbf
\renewcommand\.{\mathord.}
\newcommand\EQ{\mathrel\Coloneqq}
\newcommand\OR[1][]{\mathrel{\mathrlap{\mkern{8mu}#1|}{\hphantom\Coloneqq}}}
\newcommand\Or{\mathrel|}
\newcommand\RV[1]{\langle#1\rangle}
\newcommand\RT[1]{\{#1\}}
\begin{aligned}
w,x,y,z &\EQ \dotsb & \text{term variables} \\[.5em]
\pi,\rho,\sigma &\EQ 0 \Or 1 \Or \dotsb \Or \omega
  & \text{atomic usages} \\[.5em]
\alpha, \beta, \gamma
    &\EQ \pi & \text{usage trees: atomic} \\
    &\OR \{\hat\xi\} & \text{nested} \\[.5em]
\xi &\EQ \bullet \Or \xi, \alpha \cdot x
  & \text{usage contexts} \\[.5em]
\hat\xi &\EQ \xi; \beta \cdot \_ & \text{usage contexts with default} \\[.5em]
s, t, A, B &\EQ \dotsb & \text{terms} \\
           &\OR \RT\Delta \Or \RV\delta & \text{record types/records} \\[.5em]
e, f &\EQ \dotsb & \text{eliminations} \\
     &\OR y\.x & \text{field lookup} \\[.5em]
\Gamma, \Delta &\EQ \bullet \Or \Gamma, \pi \cdot x : A
          & \text{contexts/telescopes} \\[.5em]
\delta &\EQ \bullet \Or \delta, x = s
          & \text{lists of fields}
\end{aligned}
%
\newcommand\Q{\mathrel|}
\newcommand\I{\textcolor{blue}} \newcommand\O{\textcolor{green}}
\let\Rule\mathsf
\newcommand\rule[3]{\frac{\begin{gathered}#2\end{gathered}}{#3}\:\Rule{#1}}
\let\Chk\Leftarrow \let\Syn\Rightarrow
\newcommand\Tel[1]{\mathbfsf{tel}\:#1}
\newcommand\Type[1]{\mathsf{type}\:#1}
$$

Due to bidirectional type checking we automatically get the information we need
to disambiguate types with shared field names:

- A record literal is a term, which means the type to check it against is also
  given upfront. (The type needs to be definitionally equal to a declared record
  type.)

- A field access is performed on an elimination, whose type can be inferred and
  we know which particular record type we're looking up into.

  - As written currently a lookup is *only* on a name, so that it is in the
    usage context and all the lookups throughout an expression can be recorded.
    In principle it would be possible to allow any elimination as long as all
    fields in its type other than $x$ are zero or $\omega$, if that would
    be a useful extension.

  - A nested lookup like $x\.y\.z$ should also be supported, but I still need to
    think about how to extend the rules to do so.

- Due to record lookups being scattered throughout an expression, we now need to
  account for usages of fields individually. For example the usage
  $\{\pi_1 \cdot x_1, \dotsc, \pi_n \cdot x_n; \rho \cdot \_\}$
  denotes that each $x_i$ has been used $\pi_i$ times, and any fields not
  listed among the $x_i$ (if any) are used $\rho$ times.

This does mean that somewhere between record construction and lookup, there will
need to be some type signature, but this is inevitable anyway due to reused
field names, as well as the fact that the fields' types might not be inferrable
themselves. It is also already the case for functions and pairs, due to
dependency making inference infeasible.

- The judgement
  $\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{s}
      \Chk \I{A} \dashv \O{\xi_O}$
  means that in type context $\Gamma$ and usage context $\xi_I$, $\sigma$ uses of
  the term $s$ can be checked against the type $A$, with the output usage
  context $\xi_O$ left over. Here the blue parts are inputs and the green parts
  outputs.

- The judgement
  $\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{e}
      \Syn \O{A} \dashv \O{\xi_O}$
  means that under the same conditions, the elimination $e$ can be inferred to
  have type $A$.

- $\I\Gamma \vdash \I\Delta \Chk \Tel{\I\ell}$
  checks that $\Delta$ is a telescope of types with level $\ell$.
  There are no usage contexts since telescopes only contain types.
  ($\Tel\ell$ is not a new type former: it just means "is a telescope".)

- $\I\Gamma \Q \I{\xi_I} \vdash \I\sigma \cdot \I\delta
      \Chk \I\Delta \dashv \O{\xi_O}$
  checks that a list of fields, after sorting them into the same order, have the
  types and usages in $\Delta$.

- $\Gamma \vdash_0 s \Chk A$ is an abbreviation for
  $\Gamma \Q 0\Gamma \vdash 0 \cdot s \Chk A \dashv 0\Gamma$, and similarly
  for $\Syn$, for checking types in an all-zero usage context.

The difference between a "context" $\Gamma$ and a "telescope" $\Delta$ is that a
telescope may already have some bindings in scope (e.g. record fields have the
parameters in scope).

## Construction

$$
\begin{gathered}
\rule{recty}{
  \Gamma \vdash \Delta \Chk \Tel\ell
}{
  \Gamma \vdash_0 \{\Delta\} \Chk \Type\ell
}\qquad
\rule{recval}{
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta
}{
  \Gamma \Q \xi \vdash
    \sigma \cdot \RV\delta \Chk \RT\Delta
    \dashv \xi_\delta
}
\\[1em]
\rule{tnil}{}{
  \Gamma \vdash \bullet \Chk \Tel\ell
}\qquad
\rule{tcons}{
  \Gamma \vdash \Delta \Chk \Tel\ell \qquad
  (\Gamma, \Delta) \vdash_0 A \Chk \Type\ell
}{
  \Gamma \vdash (\Delta, \pi \cdot x : A) \Chk \Tel\ell
}\\[1em]
\rule{fnil}{}{
  \Gamma \Q \xi \vdash \sigma \cdot \bullet \Chk \bullet \dashv \xi
}
\\[.5em]
\rule{fcons}{
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta \qquad
  (\Gamma, \Delta) \Q (\xi_\delta, 0\Delta) \vdash \sigma\rho \cdot s
      \Chk A \dashv (\xi_s, 0\Delta)
}{
  \Gamma \Q \xi \vdash \sigma \cdot (\delta, x = s) \Chk
    (\Delta, \rho \cdot x : A) \dashv \xi_s
}
\end{gathered}
%
\let\N\mathsf
$$

Things to note:

- This formulation of $\Rule{fcons}$ does not allow earlier fields to occur
  nonzero in later ones. That's probably fixable by making the rule more complex
  but I haven't figured out the details yet, and it is possible to add in
  future.

- The fields of $\delta$ can be in any order, but they are checked in the order
  of $\Delta$. For example, you can write
  $\RV{\N{p} = \Con{refl}, \N{a} = 1, \N{b} = 2}$ for
  $\RT{1\cdot\N{a}: \N{Nat}, 1\cdot\N{b}: \N{Nat},
       0\cdot\N{p}: \N{a} + \N{b} = 3}$.
  The rules assume that the fields have been reordered already.


- The telescope checking from functions can probably be reused for checking
  a record declaration.

## Lookup

__TODO path lookup__

$$
\rule{look}{
  \Gamma \vdash_0 w \Syn \RT\Delta \qquad
  \mathsf{names}(\Delta) = \overline{x_i}, y, \overline{z_j}
}{
  \Gamma \Q \xi \vdash \sigma \cdot w\.y \Syn
    B\overline{[y\.x_i / x_i]}
    \dashv \xi - (\{\sigma \cdot y; 0 \cdot \_\} \cdot w)
}
$$

- The weirdest-looking part of this is probably that $w$ is checked in a zero
  context. That's because it's only the subfield $w\.y$ that is being consumed,
  not the whole record.

- Since records can be dependent, the output type has the previous fields
  substituted with lookups into $w$.

- The output usage is the same as that of the record itself but with the extra
  use of the field $x$ also subtracted.


# Usage compatibility & subtraction

Since usages are trees now, compatibility $\let\Comp\preceq\Comp$ and
subtraction $-$ are more complicated than before. The order of fields in
$\xi$ is unimportant since there are no dependent usages, so the rules for
$\Comp$ assume they are in the same order in both arguments.

Essentially both compatibility and subtraction recurse through both trees in
lockstep, duplicating out an atomic usage when one tree stops earlier than the
other.

A subtree is compatible with an atomic usage when all of its leaves are
compatible with it (in either direction).

$$
\begin{gathered}
\rule{urefl}{}{\sigma \Comp \sigma}
\qquad
\rule{uomega}{}{\sigma \Comp \omega}
\\[.5em]
\rule{umatch}{
  \{\hat\xi_1\} \Comp \{\hat\xi_2\} \qquad
  \pi_1 \Comp \pi_2
}{
  \{\pi_1 \cdot x, \hat\xi_1\} \Comp \{\pi_2 \cdot x, \hat\xi_2\}
}
\qquad
\rule{udef}{
  \{\hat\xi_1\} \Comp \{\xi_2; \rho \cdot \_\} \qquad
  \pi \Comp \rho
}{
  \{\pi \cdot x, \hat\xi_1\} \Comp \{\xi_2; \rho \cdot \_\}
}
\\[.5em]
\rule{uend}{
  \pi \Comp \rho
}{
  \{\bullet; \pi \cdot \_\} \Comp \{\bullet; \rho \cdot \_\}
}
\\[.5em]
\rule{uall1}{
  \overline{\pi_i \Comp \sigma} \qquad
  \rho \Comp \sigma
}{
  \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\} \Comp \sigma
}
\qquad
\rule{uall2}{
  \overline{\sigma \Comp \pi_i} \qquad
  \sigma \Comp \rho
}{
  \sigma \Comp \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\}
}
\end{gathered}
$$

Similarly, a subtraction between a tree and an atomic usage duplicates the
atom into a tree of the same shape and does each subtraction in turn. This was
easier to just write in haskell, so:

```haskell
treeMinus :: CanTC m => UsageTree -> UsageTree -> m UsageTree
treeMinus = onTree \π ρ -> maybe _TypeError pure $ π `minus` ρ

onTree :: Alternative f
       => (Usage.T -> Usage.T -> f Usage.T)
       -> UsageTree -> UsageTree -> f UsageTree
onTree op (TOne π) (TOne ρ) =
  TOne <$> op π ρ
onTree op (TOne π) (TRecord fs o) =
  TRecord <$> traverse (onTree op (TOne π)) fs
          <*> (onTree op (TOne π) o)
onTree op (TRecord fs o) (TOne ρ) =
  TRecord <$> traverse (flip (onTree op) (TOne ρ)) fs
          <*> (onTree op o (TOne ρ))
onTree op (TRecord fs1 o1) (TRecord fs2 o2) =
  TRecord <$> (Map.fromList <$> traverse opField fs)
          <*> (onTree op o1 o2)
 where
  fs = Set.toList $ keysSet fs1 <> keysSet fs2
  opField f = (f,) <$>
    onTree op
      (Map.findWithDefault o1 f fs1)
      (Map.findWithDefault o2 f fs2)
```


# Evaluation

$$
\begin{aligned}
u, v &\EQ \dotsb \Or \{\bar\delta\} & \text{values: record}
\\[.5em]
n &\EQ \dotsb \Or x\.y & \text{neutrals: lookup}
\\[.5em]
\bar\delta &\EQ \bullet \Or \bar\delta, x = v
  & \text{list of value fields}
\end{aligned}
$$

Honestly this part is just what you think it is. To evaluate a record, evaluate
its contents; and to evaluate a lookup, project out the appropriate bit.

$$
\let\Eval\rightsquigarrow
\begin{gathered}
\rule{erecord}{
  \overline{s_i \Eval v_i}
}{
  \{\overline{x_i = s_i}\} \Eval
  \{\overline{x_i = v_i}\}
}
\qquad
\rule{elook}{
  x \Eval \{\bar\delta_1, y = v, \bar\delta_2\}
}{
  x\.y \Eval v
}
\end{gathered}
$$


# Other stuff

- Previously this document talked about records as top-level declarations, but
  it seems anonymous record types are no more complex to implement so the focus
  has been changed to that.

- We can also replace $\square_\pi\:A$ with something like
  $\RT{\pi \cdot \mathsf{val}: A}$.

- Pairs can be replaced with something like
  $\RT{\pi \cdot \mathsf{fst}: A, \rho \cdot \mathsf{snd}: B \: \mathsf{fst}}$,
  which can even have differing usages for the two components.
