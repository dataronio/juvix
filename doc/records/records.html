<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Records (partially) in core</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Records (partially) in core</h1>
</header>
<h1 id="syntax-changes">Syntax changes</h1>
<p>tl;dr: Add a new kind of datatype for records, a new term for constructing them, and a new elim for looking up. A usage context is a tree now since we’re tracking fields of records separately.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- in Juvix.Core.Base.Types.Base</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> primTy primVal</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RecordTy</span> [(<span class="dt">Symbol</span>, <span class="dt">Usage.T</span>, <span class="dt">Term</span> primTy primVal)]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Record</span>   (<span class="dt">Map</span> <span class="dt">Symbol</span> (<span class="dt">Term</span> primTy primVal))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Elim</span> primTy primVal</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lookup</span> <span class="dt">Name</span> <span class="dt">Symbol</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> primTy primVal</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">VRecordTy</span> (<span class="dt">Map</span> <span class="dt">Symbol</span> (<span class="dt">Usage.T</span>, <span class="dt">Value</span> primTy primVal))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">VRecord</span>   (<span class="dt">Map</span> <span class="dt">Symbol</span> (<span class="dt">Value</span> primTy primVal))</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Neutral</span> primTy primVal</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NLookups</span> <span class="dt">Name</span> [<span class="dt">Symbol</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- in Juvix.Core.IR.Typechecker.Types</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Annotation</span> ext primTy primVal <span class="ot">=</span> <span class="dt">Annotation</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> annUsage ::</span> <span class="dt">UsageTree</span>, <span class="co">-- was Usage.T</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="ot">    annType ::</span> <span class="dt">Core.Value</span> ext primTy primVal</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TOne</span> a</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="co">-- | second arg is for any field not mentioned in the map</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">TRecord</span> (<span class="dt">Map</span> <span class="dt">Symbol</span> (<span class="dt">Tree</span> a)) (<span class="dt">Tree</span> a)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UsageTree</span> <span class="ot">=</span> <span class="dt">Tree</span> <span class="dt">Usage.T</span></span></code></pre></div>
<h1 id="type-rules">Type rules</h1>
<p><span class="math display">\[
\let\Con\mathbf
\renewcommand\.{\mathord.}
\newcommand\EQ{\mathrel\Coloneqq}
\newcommand\OR[1][]{\mathrel{\mathrlap{\mkern{8mu}#1|}{\hphantom\Coloneqq}}}
\newcommand\Or{\mathrel|}
\newcommand\RV[1]{\langle#1\rangle}
\newcommand\RT[1]{\{#1\}}
\begin{aligned}
w,x,y,z &amp;\EQ \dotsb &amp; \text{term variables} \\[.5em]
\pi,\rho,\sigma &amp;\EQ 0 \Or 1 \Or \dotsb \Or \omega
  &amp; \text{atomic usages} \\[.5em]
\alpha, \beta, \gamma
    &amp;\EQ \pi &amp; \text{usage trees: atomic} \\
    &amp;\OR \{\hat\xi\} &amp; \text{nested} \\[.5em]
\xi &amp;\EQ \bullet \Or \xi, \alpha \cdot x
  &amp; \text{usage contexts} \\[.5em]
\hat\xi &amp;\EQ \xi; \beta \cdot \_ &amp; \text{usage contexts with default} \\[.5em]
s, t, A, B &amp;\EQ \dotsb &amp; \text{terms} \\
           &amp;\OR \RT\Delta \Or \RV\delta &amp; \text{record types/records} \\[.5em]
e, f &amp;\EQ \dotsb &amp; \text{eliminations} \\
     &amp;\OR y\.x &amp; \text{field lookup} \\[.5em]
\Gamma, \Delta &amp;\EQ \bullet \Or \Gamma, \pi \cdot x : A
          &amp; \text{contexts/telescopes} \\[.5em]
\delta &amp;\EQ \bullet \Or \delta, x = s
          &amp; \text{lists of fields}
\end{aligned}
%
\newcommand\Q{\mathrel|}
\newcommand\I{\textcolor{blue}} \newcommand\O{\textcolor{green}}
\let\Rule\mathsf
\newcommand\rule[3]{\frac{\begin{gathered}#2\end{gathered}}{#3}\:\Rule{#1}}
\let\Chk\Leftarrow \let\Syn\Rightarrow
\newcommand\Tel[1]{\mathbfsf{tel}\:#1}
\newcommand\Type[1]{\mathsf{type}\:#1}
\]</span></p>
<p>Due to bidirectional type checking we automatically get the information we need to disambiguate types with shared field names:</p>
<ul>
<li><p>A record literal is a term, which means the type to check it against is also given upfront. (The type needs to be definitionally equal to a declared record type.)</p></li>
<li><p>A field access is performed on an elimination, whose type can be inferred and we know which particular record type we’re looking up into.</p>
<ul>
<li><p>As written currently a lookup is <em>only</em> on a name, so that it is in the usage context and all the lookups throughout an expression can be recorded. In principle it would be possible to allow any elimination as long as all fields in its type other than <span class="math inline">\(x\)</span> are zero or <span class="math inline">\(\omega\)</span>, if that would be a useful extension.</p></li>
<li><p>A nested lookup like <span class="math inline">\(x\.y\.z\)</span> should also be supported, but I still need to think about how to extend the rules to do so.</p></li>
</ul></li>
<li><p>Due to record lookups being scattered throughout an expression, we now need to account for usages of fields individually. For example the usage <span class="math inline">\(\{\pi_1 \cdot x_1, \dotsc, \pi_n \cdot x_n; \rho \cdot \_\}\)</span> denotes that each <span class="math inline">\(x_i\)</span> has been used <span class="math inline">\(\pi_i\)</span> times, and any fields not listed among the <span class="math inline">\(x_i\)</span> (if any) are used <span class="math inline">\(\rho\)</span> times.</p></li>
</ul>
<p>This does mean that somewhere between record construction and lookup, there will need to be some type signature, but this is inevitable anyway due to reused field names, as well as the fact that the fields’ types might not be inferrable themselves. It is also already the case for functions and pairs, due to dependency making inference infeasible.</p>
<ul>
<li><p>The judgement <span class="math inline">\(\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{s}  \Chk \I{A} \dashv \O{\xi_O}\)</span> means that in type context <span class="math inline">\(\Gamma\)</span> and usage context <span class="math inline">\(\xi_I\)</span>, <span class="math inline">\(\sigma\)</span> uses of the term <span class="math inline">\(s\)</span> can be checked against the type <span class="math inline">\(A\)</span>, with the output usage context <span class="math inline">\(\xi_O\)</span> left over. Here the blue parts are inputs and the green parts outputs.</p></li>
<li><p>The judgement <span class="math inline">\(\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{e}  \Syn \O{A} \dashv \O{\xi_O}\)</span> means that under the same conditions, the elimination <span class="math inline">\(e\)</span> can be inferred to have type <span class="math inline">\(A\)</span>.</p></li>
<li><p><span class="math inline">\(\I\Gamma \vdash \I\Delta \Chk \Tel{\I\ell}\)</span> checks that <span class="math inline">\(\Delta\)</span> is a telescope of types with level <span class="math inline">\(\ell\)</span>. There are no usage contexts since telescopes only contain types. (<span class="math inline">\(\Tel\ell\)</span> is not a new type former: it just means “is a telescope”.)</p></li>
<li><p><span class="math inline">\(\I\Gamma \Q \I{\xi_I} \vdash \I\sigma \cdot \I\delta  \Chk \I\Delta \dashv \O{\xi_O}\)</span> checks that a list of fields, after sorting them into the same order, have the types and usages in <span class="math inline">\(\Delta\)</span>.</p></li>
<li><p><span class="math inline">\(\Gamma \vdash_0 s \Chk A\)</span> is an abbreviation for <span class="math inline">\(\Gamma \Q 0\Gamma \vdash 0 \cdot s \Chk A \dashv 0\Gamma\)</span>, and similarly for <span class="math inline">\(\Syn\)</span>, for checking types in an all-zero usage context.</p></li>
</ul>
<p>The difference between a “context” <span class="math inline">\(\Gamma\)</span> and a “telescope” <span class="math inline">\(\Delta\)</span> is that a telescope may already have some bindings in scope (e.g. record fields have the parameters in scope).</p>
<h2 id="construction">Construction</h2>
<p><span class="math display">\[
\begin{gathered}
\rule{recty}{
  \Gamma \vdash \Delta \Chk \Tel\ell
}{
  \Gamma \vdash_0 \{\Delta\} \Chk \Type\ell
}\qquad
\rule{recval}{
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta
}{
  \Gamma \Q \xi \vdash
    \sigma \cdot \RV\delta \Chk \RT\Delta
    \dashv \xi_\delta
}
\\[1em]
\rule{tnil}{}{
  \Gamma \vdash \bullet \Chk \Tel\ell
}\qquad
\rule{tcons}{
  \Gamma \vdash \Delta \Chk \Tel\ell \qquad
  (\Gamma, \Delta) \vdash_0 A \Chk \Type\ell
}{
  \Gamma \vdash (\Delta, \pi \cdot x : A) \Chk \Tel\ell
}\\[1em]
\rule{fnil}{}{
  \Gamma \Q \xi \vdash \sigma \cdot \bullet \Chk \bullet \dashv \xi
}
\\[.5em]
\rule{fcons}{
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta \qquad
  (\Gamma, \Delta) \Q (\xi_\delta, 0\Delta) \vdash \sigma\rho \cdot s
      \Chk A \dashv (\xi_s, 0\Delta)
}{
  \Gamma \Q \xi \vdash \sigma \cdot (\delta, x = s) \Chk
    (\Delta, \rho \cdot x : A) \dashv \xi_s
}
\end{gathered}
%
\let\N\mathsf
\]</span></p>
<p>Things to note:</p>
<ul>
<li><p>This formulation of <span class="math inline">\(\Rule{fcons}\)</span> does not allow earlier fields to occur nonzero in later ones. That’s probably fixable by making the rule more complex but I haven’t figured out the details yet, and it is possible to add in future.</p></li>
<li><p>The fields of <span class="math inline">\(\delta\)</span> can be in any order, but they are checked in the order of <span class="math inline">\(\Delta\)</span>. For example, you can write <span class="math inline">\(\RV{\N{p} = \Con{refl}, \N{a} = 1, \N{b} = 2}\)</span> for <span class="math inline">\(\RT{1\cdot\N{a}: \N{Nat}, 1\cdot\N{b}: \N{Nat},  0\cdot\N{p}: \N{a} + \N{b} = 3}\)</span>. The rules assume that the fields have been reordered already.</p></li>
<li><p>The telescope checking from functions can probably be reused for checking a record declaration.</p></li>
</ul>
<h2 id="lookup">Lookup</h2>
<p><strong>TODO path lookup</strong></p>
<p><span class="math display">\[
\rule{look}{
  \Gamma \vdash_0 w \Syn \RT\Delta \qquad
  \mathsf{names}(\Delta) = \overline{x_i}, y, \overline{z_j}
}{
  \Gamma \Q \xi \vdash \sigma \cdot w\.y \Syn
    B\overline{[y\.x_i / x_i]}
    \dashv \xi - (\{\sigma \cdot y; 0 \cdot \_\} \cdot w)
}
\]</span></p>
<ul>
<li><p>The weirdest-looking part of this is probably that <span class="math inline">\(w\)</span> is checked in a zero context. That’s because it’s only the subfield <span class="math inline">\(w\.y\)</span> that is being consumed, not the whole record.</p></li>
<li><p>Since records can be dependent, the output type has the previous fields substituted with lookups into <span class="math inline">\(w\)</span>.</p></li>
<li><p>The output usage is the same as that of the record itself but with the extra use of the field <span class="math inline">\(x\)</span> also subtracted.</p></li>
</ul>
<h1 id="usage-compatibility-subtraction">Usage compatibility &amp; subtraction</h1>
<p>Since usages are trees now, compatibility <span class="math inline">\(\let\Comp\preceq\Comp\)</span> and subtraction <span class="math inline">\(-\)</span> are more complicated than before. The order of fields in <span class="math inline">\(\xi\)</span> is unimportant since there are no dependent usages, so the rules for <span class="math inline">\(\Comp\)</span> assume they are in the same order in both arguments.</p>
<p>Essentially both compatibility and subtraction recurse through both trees in lockstep, duplicating out an atomic usage when one tree stops earlier than the other.</p>
<p>A subtree is compatible with an atomic usage when all of its leaves are compatible with it (in either direction).</p>
<p><span class="math display">\[
\begin{gathered}
\rule{urefl}{}{\sigma \Comp \sigma}
\qquad
\rule{uomega}{}{\sigma \Comp \omega}
\\[.5em]
\rule{umatch}{
  \{\hat\xi_1\} \Comp \{\hat\xi_2\} \qquad
  \pi_1 \Comp \pi_2
}{
  \{\pi_1 \cdot x, \hat\xi_1\} \Comp \{\pi_2 \cdot x, \hat\xi_2\}
}
\qquad
\rule{udef}{
  \{\hat\xi_1\} \Comp \{\xi_2; \rho \cdot \_\} \qquad
  \pi \Comp \rho
}{
  \{\pi \cdot x, \hat\xi_1\} \Comp \{\xi_2; \rho \cdot \_\}
}
\\[.5em]
\rule{uend}{
  \pi \Comp \rho
}{
  \{\bullet; \pi \cdot \_\} \Comp \{\bullet; \rho \cdot \_\}
}
\\[.5em]
\rule{uall1}{
  \overline{\pi_i \Comp \sigma} \qquad
  \rho \Comp \sigma
}{
  \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\} \Comp \sigma
}
\qquad
\rule{uall2}{
  \overline{\sigma \Comp \pi_i} \qquad
  \sigma \Comp \rho
}{
  \sigma \Comp \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\}
}
\end{gathered}
\]</span></p>
<p>Similarly, a subtraction between a tree and an atomic usage duplicates the atom into a tree of the same shape and does each subtraction in turn. This was easier to just write in haskell, so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeMinus ::</span> <span class="dt">CanTC</span> m <span class="ot">=&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> m <span class="dt">UsageTree</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>treeMinus <span class="ot">=</span> onTree \π ρ <span class="ot">-&gt;</span> <span class="fu">maybe</span> _TypeError <span class="fu">pure</span> <span class="op">$</span> π <span class="ot">`minus`</span> ρ</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">onTree ::</span> <span class="dt">Alternative</span> f</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=&gt;</span> (<span class="dt">Usage.T</span> <span class="ot">-&gt;</span> <span class="dt">Usage.T</span> <span class="ot">-&gt;</span> f <span class="dt">Usage.T</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> f <span class="dt">UsageTree</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>onTree op (<span class="dt">TOne</span> π) (<span class="dt">TOne</span> ρ) <span class="ot">=</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TOne</span> <span class="op">&lt;$&gt;</span> op π ρ</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>onTree op (<span class="dt">TOne</span> π) (<span class="dt">TRecord</span> fs o) <span class="ot">=</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TRecord</span> <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> (onTree op (<span class="dt">TOne</span> π)) fs</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (onTree op (<span class="dt">TOne</span> π) o)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>onTree op (<span class="dt">TRecord</span> fs o) (<span class="dt">TOne</span> ρ) <span class="ot">=</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TRecord</span> <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> (<span class="fu">flip</span> (onTree op) (<span class="dt">TOne</span> ρ)) fs</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (onTree op o (<span class="dt">TOne</span> ρ))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>onTree op (<span class="dt">TRecord</span> fs1 o1) (<span class="dt">TRecord</span> fs2 o2) <span class="ot">=</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TRecord</span> <span class="op">&lt;$&gt;</span> (Map.fromList <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> opField fs)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (onTree op o1 o2)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  fs <span class="ot">=</span> Set.toList <span class="op">$</span> keysSet fs1 <span class="op">&lt;&gt;</span> keysSet fs2</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  opField f <span class="ot">=</span> (f,) <span class="op">&lt;$&gt;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    onTree op</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>      (Map.findWithDefault o1 f fs1)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>      (Map.findWithDefault o2 f fs2)</span></code></pre></div>
<h1 id="evaluation">Evaluation</h1>
<p><span class="math display">\[
\begin{aligned}
u, v &amp;\EQ \dotsb \Or \{\bar\delta\} &amp; \text{values: record}
\\[.5em]
n &amp;\EQ \dotsb \Or x\.y &amp; \text{neutrals: lookup}
\\[.5em]
\bar\delta &amp;\EQ \bullet \Or \bar\delta, x = v
  &amp; \text{list of value fields}
\end{aligned}
\]</span></p>
<p>Honestly this part is just what you think it is. To evaluate a record, evaluate its contents; and to evaluate a lookup, project out the appropriate bit.</p>
<p><span class="math display">\[
\let\Eval\rightsquigarrow
\begin{gathered}
\rule{erecord}{
  \overline{s_i \Eval v_i}
}{
  \{\overline{x_i = s_i}\} \Eval
  \{\overline{x_i = v_i}\}
}
\qquad
\rule{elook}{
  x \Eval \{\bar\delta_1, y = v, \bar\delta_2\}
}{
  x\.y \Eval v
}
\end{gathered}
\]</span></p>
<h1 id="other-stuff">Other stuff</h1>
<ul>
<li><p>Previously this document talked about records as top-level declarations, but it seems anonymous record types are no more complex to implement so the focus has been changed to that.</p></li>
<li><p>We can also replace <span class="math inline">\(\square_\pi\:A\)</span> with something like <span class="math inline">\(\RT{\pi \cdot \mathsf{val}: A}\)</span>.</p></li>
<li><p>Pairs can be replaced with something like <span class="math inline">\(\RT{\pi \cdot \mathsf{fst}: A, \rho \cdot \mathsf{snd}: B \: \mathsf{fst}}\)</span>, which can even have differing usages for the two components.</p></li>
</ul>
</body>
</html>
