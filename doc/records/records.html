<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Records (partially) in core</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Records (partially) in core</h1>
</header>
<h1 id="syntax-changes">Syntax changes</h1>
<p>tl;dr: Add a new kind of datatype for records, a new term for constructing them, and a new elim for looking up. A usage context is a tree now since we’re tracking fields of records separately.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- in Juvix.Core.Base.Types.Base</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> primTy primVal</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Record</span> [(<span class="dt">Symbol</span>, <span class="dt">Term</span> primTy primVal)]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Elim</span> primTy primVal</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Having an arbitrary elimination as the head is in principle possible, but</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- will only be typeable in a non-&#39;Name&#39; case if the record only has that one</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- nonzero, non-ω field. If it is a name then it is in the context and it will</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- be possible to count the usages of the fields individually.</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Even so it would be possible to change the head to a general &#39;Elim&#39; and</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- so that an immediate lookup is possible for records with one relevant</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- field bundled with some proofs for example.</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lookups</span> <span class="dt">Name</span> [<span class="dt">Symbol</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> primTy primVal</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">VRecord</span> [(<span class="dt">Symbol</span>, <span class="dt">Value</span> primTy primVal)]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Neutral</span> primTy primVal</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NLookup</span> (<span class="dt">Neutral</span> primTy primVal) <span class="dt">Symbol</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- in Juvix.Core.Base.Types.Globals</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Record</span> ext primTy primVal <span class="ot">=</span> <span class="dt">RecordTy</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> recordName ::</span> <span class="dt">GlobalName</span>,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="ot">    recordArgs ::</span> [<span class="dt">DataArg</span> ext primTy primVal],</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="ot">    recordLevel ::</span> <span class="dt">Natural</span>,</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="ot">    recordFields ::</span> [<span class="dt">Field</span> ext primTy primVal]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Global</span> extV extT primTy primVal</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">GRecord</span> (<span class="dt">Record</span> extV primTy primVal)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- in Juvix.Core.IR.Typechecker.Types</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Annotation</span> ext primTy primVal <span class="ot">=</span> <span class="dt">Annotation</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> annUsage ::</span> <span class="dt">UsageTree</span>, <span class="co">-- was Usage.T</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="ot">    annType ::</span> <span class="dt">Core.Value</span> ext primTy primVal</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UsageTree</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">UOne</span> <span class="dt">Usage.T</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="co">-- | second field is the usage of any field not mentioned in the map</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">URecord</span> (<span class="dt">Map</span> <span class="dt">Symbol</span> <span class="dt">UsageTree</span>) <span class="dt">UsageTree</span></span></code></pre></div>
<h1 id="type-rules">Type rules</h1>
<p><span class="math display">\[
\let\Kw\mathsf \let\Con\mathbf
\renewcommand\.{\mathord.}
\newcommand\EQ{\mathrel\Coloneqq}
\newcommand\OR[1][]{\mathrel{\mathrlap{\mkern{8mu}#1|}{\hphantom\Coloneqq}}}
\newcommand\Or{\mathrel|}
\begin{aligned}
w,x,y,z &amp;\EQ \dotsb &amp; \text{term variables} \\[.5em]
\pi,\rho,\sigma &amp;\EQ 0 \Or 1 \Or \dotsb \Or \omega
  &amp; \text{atomic usages} \\[.5em]
\alpha, \beta &amp;\EQ \pi &amp; \text{usage trees: atomic} \\
                &amp;\OR \{\hat\xi\} &amp; \text{nested} \\[.5em]
\xi &amp;\EQ \bullet \Or \xi, \alpha \cdot x
  &amp; \text{usage contexts} \\[.5em]
\hat\xi &amp;\EQ \xi; \beta \cdot \_ &amp; \text{usage contexts with default} \\[.5em]
\Gamma, \Delta &amp;\EQ \bullet \Or \Gamma, \pi \cdot x : A
          &amp; \text{contexts \&amp; telescopes} \\[.5em]
\delta &amp;\EQ \bullet \Or \delta, x = s
          &amp; \text{lists of fields} \\[.5em]
s, t, A, B &amp;\EQ \dotsb &amp; \text{terms} \\
           &amp;\OR \{ \delta \} &amp; \text{records} \\[.5em]
e, f &amp;\EQ \dotsb &amp; \text{eliminations} \\
     &amp;\OR y\.p &amp; \text{field lookup} \\[.5em]
p &amp;\EQ x \Or p\.x &amp; \text{paths} \\[.5em]
\mathbb{D} &amp;\EQ \dotsb &amp; \text{declarations} \\
           &amp;\OR \Kw{type}\: \Con{R} \: \Delta_1 : \Kw{ty}_i =
              \{ \Delta_2 \}
              &amp; \text{records}
\end{aligned}
%
\newcommand\Q{\mathrel|}
\newcommand\I{\textcolor{blue}} \newcommand\O{\textcolor{green}}
\let\Rec\Con
\let\Rule\mathsf
\newcommand{rule}[3]{\frac{\begin{gathered}#2\end{gathered}}{#3}\:\Rule{#1}}
\let\Chk\Leftarrow \let\Syn\Rightarrow
\]</span></p>
<p>Due to bidirectional type checking we automatically get the information we need to disambiguate types with shared field names:</p>
<ul>
<li><p>A record literal is a term, which means the type to check it against is also given upfront. (The type needs to be definitionally equal to a declared record type.)</p></li>
<li><p>A field access is performed on a name, which is an elimination, whose type can be inferred and we know which particular record type we’re looking up into.</p></li>
<li><p>Due to record lookups being scattered throughout an expression, we now need to account for usages of fields individually. For example the usage <span class="math inline">\(\{\pi_1 \cdot x_1, \dotsc, \pi_n \cdot x_n; \rho \cdot \_\}\)</span> denotes that each <span class="math inline">\(x_i\)</span> has been used <span class="math inline">\(\pi_i\)</span> times, and any fields not listed among the <span class="math inline">\(x_i\)</span> (if any) are used <span class="math inline">\(\rho\)</span> times.</p></li>
</ul>
<p>This does mean that somewhere between record construction and lookup, there will need to be some type signature, but this is inevitable anyway due to reused field names, as well as the fact that the fields’ definitions might not be inferrable themselves. It is also already the case for functions and pairs, due to dependency making inference infeasible.</p>
<ul>
<li><p>The judgement <span class="math inline">\(\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{s}  \Chk \I{A} \dashv \O{\xi_O}\)</span> means that in type context <span class="math inline">\(\Gamma\)</span> and usage context <span class="math inline">\(\xi_I\)</span>, <span class="math inline">\(\sigma\)</span> uses of the term <span class="math inline">\(s\)</span> can be checked against the type <span class="math inline">\(A\)</span>, with the output usage context <span class="math inline">\(\xi_O\)</span> left over. Here the blue parts are inputs and the green parts outputs.</p></li>
<li><p>The judgement <span class="math inline">\(\I\Gamma \Q \I{\xi_I} \vdash \I{\sigma} \cdot \I{e}  \Syn \O{A} \dashv \O{\xi_O}\)</span> means that under the same conditions, the elimination <span class="math inline">\(e\)</span> can be inferred to have type <span class="math inline">\(A\)</span>.</p></li>
<li><p>“<span class="math inline">\(\I{A}\)</span> is a record with fields <span class="math inline">\(\O\Delta\)</span>” means that <span class="math inline">\(A\)</span> must evaluate to an application <span class="math inline">\(\Rec{R}\:\overline{B}\)</span> of some declared record type <span class="math inline">\(\Rec{R}\)</span> applied to some parameters, and its fields, <em>after</em> substituting in the parameters, are <span class="math inline">\(\Delta\)</span>.</p></li>
</ul>
<p>The difference between a “context” <span class="math inline">\(\Gamma\)</span> and a “telescope” <span class="math inline">\(\Delta\)</span> is that a telescope may already have some bindings in scope (e.g. record fields have the parameters in scope).</p>
<h2 id="construction">Construction</h2>
<p><span class="math display">\[
\begin{gathered}
\rule{record}{
  \text{$A$ is a record with fields $\Delta$} \qquad
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta
}{
  \Gamma \Q \xi \vdash \sigma \cdot \{\delta\} \Chk A \dashv \xi_\delta
}
\\[1em]
\rule{rnil}{}{
  \Gamma \Q \xi \vdash \sigma \cdot \bullet \Chk \bullet \dashv \xi
}
\\[.5em]
\rule{rcons}{
  \Gamma \Q \xi \vdash \sigma \cdot \delta \Chk \Delta \dashv \xi_\delta \qquad
  (\Gamma, \Delta) \Q (\xi_\delta, 0\Delta) \vdash \sigma\rho \cdot s
      \Chk A \dashv (\xi_s, 0\Delta)
}{
  \Gamma \Q \xi \vdash \sigma \cdot (\delta, x = s) \Chk
    (\Delta, \rho \cdot x : A) \dashv \xi_s
}
\end{gathered}
\]</span></p>
<p>Things to note:</p>
<ul>
<li><p>This formulation of <span class="math inline">\(\Rule{record}\)</span> does not allow earlier fields to occur nonzero in later ones. That’s probably fixable by making the rule more complex but I haven’t figured out the details yet and it’s is possible to add in future.</p></li>
<li><p>The order of type dependency follows the record declaration rather than the order the fields are listed.</p></li>
<li><p>The telescope checking from functions can probably be reused for checking a record declaration.</p></li>
</ul>
<h2 id="lookup">Lookup</h2>
<p><strong>TODO path lookup</strong></p>
<p><span class="math display">\[
\rule{look}{
  \Gamma \Q 0\Gamma \vdash 0 \cdot w \Syn A \dashv 0\Gamma \qquad
  \text{$A$ is a record with fields $\Delta$} \\
  \mathsf{names}(\Delta) = \overline{x_i}, y, \overline{z_j}
}{
  \Gamma \Q \xi \vdash \sigma \cdot w\.y \Syn
    B\overline{[y\.x_i / x_i]}
    \dashv \xi_w \ominus (\{\sigma \cdot y; 0 \cdot \_\} \cdot w)
}
\]</span></p>
<ul>
<li><p>The weirdest-looking part of this is probably that <span class="math inline">\(w\)</span> is checked in a zero context. That’s because it’s only the subfield <span class="math inline">\(w\.y\)</span> that is being consumed, not the whole record.</p></li>
<li><p>Since records can be dependent, the output type has the previous fields substituted with more lookups into the same record.</p></li>
<li><p>Like in construction, the <span class="math inline">\(\mathsf{names}\)</span> function returns the field names in the order in the original type declaration.</p></li>
<li><p>The output usage is the same as that of the record itself but with the extra use of the field <span class="math inline">\(x\)</span> also subtracted.</p></li>
<li><p>This rule currently only allows a single level of lookup, meaning it’s necessary to replace <code>x.y.z</code> with <code>let xy = x.y in xy.z</code>. This could be done in an extra desugaring step, or if necessary this rule can also be extended. I just don’t have a nice way to do the nested usage counting yet.</p></li>
</ul>
<h1 id="usage-compatibility-subtraction">Usage compatibility &amp; subtraction</h1>
<p>Since usages are trees now, compatibility <span class="math inline">\(\let\Comp\preceq\Comp\)</span> and subtraction <span class="math inline">\(\ominus\)</span> are more complicated than before. The order of fields in <span class="math inline">\(\xi\)</span> is unimportant since there are no dependent usages, so the rules for <span class="math inline">\(\Comp\)</span> assume they are in the same order in both arguments.</p>
<p>Essentially both compatibility and subtraction recurse through both trees in lockstep, duplicating out an atomic usage when one tree stops earlier than the other.</p>
<p>A subtree is compatible with an atomic usage when all of its leaves are compatible with it (in either direction).</p>
<p><span class="math display">\[
\begin{gathered}
\rule{urefl}{}{\sigma \Comp \sigma}
\qquad
\rule{uomega}{}{\sigma \Comp \omega}
\\[.5em]
\rule{ucons}{
  \{\hat\xi_1\} \Comp \{\hat\xi_2\} \qquad
  \pi_1 \Comp \pi_2
}{
  \{\pi_1 \cdot x, \hat\xi_1\} \Comp \{\pi_2 \cdot x, \hat\xi_2\}
}
\qquad
\rule{uskip}{
  \{\hat\xi_1\} \Comp \{\hat\xi_2\} \qquad
  0 \Comp \pi
}{
  \{\pi \cdot x, \hat\xi_1\} \Comp \{\hat\xi_2\}
}
\\[.5em]
\rule{uend}{
  \pi \Comp \rho
}{
  \{\bullet; \pi \cdot \_\} \Comp \{\bullet; \rho \cdot \_\}
}
\\[.5em]
\rule{uall1}{
  \overline{\pi_i \Comp \sigma} \qquad
  \rho \Comp \sigma
}{
  \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\} \Comp \sigma
}
\qquad
\rule{uall2}{
  \overline{\sigma \Comp \pi_i} \qquad
  \sigma \Comp \rho
}{
  \sigma \Comp \{\overline{\pi_i \cdot x_i}; \rho \cdot \_\}
}
\end{gathered}
\]</span></p>
<p>Similarly, a subtraction between a tree and an atomic usage duplicates the atom into a tree of the same shape and does each subtraction in turn. This was easier to just write in haskell, so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeMinus ::</span> <span class="dt">CanTC</span> m <span class="ot">=&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> <span class="dt">UsageTree</span> <span class="ot">-&gt;</span> m <span class="dt">UsageTree</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">UOne</span> π <span class="ot">`treeMinus`</span> <span class="dt">UOne</span> ρ <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">maybe</span> _TypeError (<span class="fu">pure</span> <span class="op">.</span> <span class="dt">UOne</span>) <span class="op">$</span> π <span class="ot">`minus`</span> ρ</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">UOne</span> π <span class="ot">`treeMinus`</span> <span class="dt">URecord</span> fs o <span class="ot">=</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">URecord</span> <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> (<span class="dt">UOne</span> π <span class="ot">`treeMinus`</span>) fs</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (<span class="dt">UOne</span> π <span class="ot">`treeMinus`</span> o)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">URecord</span> fs o <span class="ot">`treeMinus`</span> <span class="dt">UOne</span> ρ <span class="ot">=</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">URecord</span> <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> (<span class="ot">`treeMinus`</span> <span class="dt">UOne</span> ρ) fs</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (o <span class="ot">`treeMinus`</span> <span class="dt">UOne</span> ρ)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dt">URecord</span> fs1 o1 <span class="ot">`treeMinus`</span> <span class="dt">URecord</span> fs2 o2 <span class="ot">=</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">URecord</span> <span class="op">&lt;$&gt;</span> (Map.fromList <span class="op">&lt;$&gt;</span> <span class="fu">traverse</span> minusField fs)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;*&gt;</span> (o1 <span class="ot">`treeMinus`</span> o2)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  fs <span class="ot">=</span> Set.toList <span class="op">$</span> keysSet fs1 <span class="op">&lt;&gt;</span> keysSet fs2</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  minusField f <span class="ot">=</span> (f,) <span class="op">&lt;$&gt;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    Map.findWithDefault o1 f fs1 <span class="ot">`treeMinus`</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    Map.findWithDefault o2 f fs2</span></code></pre></div>
<h1 id="evaluation">Evaluation</h1>
<p><span class="math display">\[
\begin{aligned}
\bar\delta &amp;\EQ \bullet \Or \bar\delta, x = v
  &amp; \text{list of value fields}
\\[.5em]
u, v &amp;\EQ \dotsb &amp; \text{values} \\
     &amp;\OR \{\bar\delta\} &amp; \text{record}
\\[.5em]
n &amp;\EQ \dotsb &amp; \text{neutrals} \\
  &amp;\OR n\.p &amp; \text{lookup}
\end{aligned}
\]</span></p>
<p>Honestly this part is just what you think it is. To evaluate a record evaluate its contents and to evaluate a lookup project out the appropriate bit. Plus congruence rules that are omitted here.</p>
<p><span class="math display">\[
\let\Eval\Longrightarrow
\begin{gathered}
\rule{erecord}{
  \overline{s_i \Eval v_i}
}{
  \{\overline{x_i = s_i}\} \Eval
  \{\overline{x_i = v_i}\}
}
\qquad
\rule{elook}{
  e \Eval \{\bar\delta_1, x = u, \bar\delta_2\}
}{
  e\.x \Eval u
}
\end{gathered}
\]</span></p>
<h1 id="other-stuff">Other stuff</h1>
<ul>
<li><p>We could have anonymous record types if that’s preferable. As long as we don’t have subtyping etc it’s just a matter of replacing “<span class="math inline">\(s \Chk A\)</span> and <span class="math inline">\(A\)</span> is a record with fields <span class="math inline">\(\Delta\)</span>” with something like “<span class="math inline">\(s \Chk \{\Delta\}\)</span>”.</p></li>
<li><p>If we do have anonymous record types, we could also replace <span class="math inline">\(\square_\pi\:A\)</span> with something like <span class="math inline">\(\{\pi \cdot \mathsf{val}: A\}\)</span>.</p></li>
<li><p>As mentioned in the comment at the beginning, it would be possible to have the head of a lookup expression be any elimination, especially if we foresee having lots of records with a single relevant field and a package of proofs that will only sometimes be needed.</p></li>
</ul>
</body>
</html>
